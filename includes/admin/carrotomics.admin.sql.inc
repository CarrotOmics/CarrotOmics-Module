<?php
/**
 * Custom functions for the CarrotOmics site
 *
 * @param $form
 * @param $form_state
 *
 * @ingroup carrotomics_admin
 */
function carrotomics_admin_sql_form($form, &$form_state) {

  // Set the breadcrumb
  $breadcrumb = [];
  $breadcrumb[] = l('Home', '<front>');
  $breadcrumb[] = l('Administration', 'admin');
  $breadcrumb[] = l('CarrotOmics', 'admin/carrotomics/sql');
  drupal_set_breadcrumb($breadcrumb);

  global $user;  // used for output file location

  // Create the form
  $form = [];

  // Add a 'Clean MD5 Checksums' button
  $form['clean_md5_btn'] = [
    '#type'   => 'submit',
    '#name'   => 'clean_md5_btn',
    '#value'  => 'Clean MD5 Checksums',
    '#prefix' => '<div style="padding-top:30px;"><em>'
                 . "Remove MD5 checksums of null strings from the feature table, these"
                 . " have the value </em>d41d8cd98f00b204e9800998ecf8427e<em>"
                 . "</em></div><br />",
    '#suffix' => "<hr>",
  ];

  // Add a 'Clean Null taxids' button
  $form['clean_taxid_btn'] = [
    '#type'   => 'submit',
    '#name'   => 'clean_taxid_btn',
    '#value'  => 'Clean Null taxids',
    '#prefix' => '<div style="padding-top:30px;"><em>'
                 . "Remove the placeholder NULL entries for GRIN or NCBI"
                 . " taxid values generated by the chado bulk loader"
                 . "</em></div><br />",
    '#suffix' => "<hr>",
  ];

  // Add a 'Populate organism abbreviations' button
  $form['pop_org_abbrev_btn'] = [
    '#type'   => 'submit',
    '#name'   => 'pop_org_abbrev_btn',
    '#value'  => 'Populate organism abbreviations',
    '#prefix' => '<div style="padding-top:30px;"><em>'
                 . "Populate any missing organism abbreviations using"
                 . " the chado_get_organism_scientific_name() function"
                 . "</em></div><br />",
    '#suffix' => "<hr>",
  ];

  // Add a 'Populate feature residues Length and Checksum' button
  $form['residues_btn'] = [
    '#type'   => 'submit',
    '#name'   => 'residues_btn',
    '#value'  => 'Populate feature residues Length and Checksum',
    '#prefix' => '<div style="padding-top:30px;"><em>'
                 . "In the chado.feature table, any record with content in the"
                 . " residues column will have the seqlen and md5checksum columns"
                 . " populated with appropriate values if they are missing."
                 . "</em></div><br />",
    '#suffix' => "<hr>",
  ];

  // Add a 'Generate QTL Abbreviations' button
  $form['qtl_abbrev_btn'] = [
    '#type'   => 'submit',
    '#name'   => 'qtl_abbrev_btn',
    '#value'  => 'Generate QTL Abbreviations',
    '#prefix' => '<div style="padding-top:30px;"><em>'
                 . "Generate featureprop entries with MAIN::published_symbol cvterm"
                 . " for all QTL lacking them, if they are of the format </em>MK012345 anytext<em>"
                 . "</em></div><br />",
    '#suffix' => "<hr>",
  ];

  // Add a 'Make marker_locus match genetic_marker' button
  $form['genetic_marker_marker_locus_fix_btn'] = [
    '#type'   => 'submit',
    '#name'   => 'genetic_marker_marker_locus_fix_btn',
    '#value'  => 'Make marker_locus match genetic_marker',
    '#prefix' => '<div style="padding-top:30px;"><em>'
                 . "Removes non-alphanumeric or underscore from all features of type genetic_marker,"
                 . " and make sure corresponding marker_locus features have the same uniquename"
                 . "</em></div><br />",
    '#suffix' => "<hr>",
  ];

  // Add a 'Populate stock_analysis' button
  $form['stock_analysis_btn'] = [
    '#type'   => 'submit',
    '#name'   => 'stock_analysis_btn',
    '#value'  => 'Generate stock_analysis links',
    '#prefix' => '<div style="padding-top:30px;"><em>'
                 . "Generate links in the chado.stock_analysis custom table using"
                 . " stocks created for phylogenetic trees. Links for both the"
                 . " tree analysis and study analysis are made."
                 . "</em></div><br />",
    '#suffix' => "<hr>",
  ];

  // Add a 'Generate map properties' button
  $form['map_prop_btn'] = [
    '#type'   => 'submit',
    '#name'   => 'map_prop_btn',
    '#value'  => 'Generate map properties',
    '#prefix' => '<div style="padding-top:30px;"><em>'
                 . "Generate chado properties for maps. These are:"
                 . " Number of markers,"
                 . " Number of linkage groups."
                 . "</em></div><br />",
    '#suffix' => "<hr>",
  ];

  // Add a 'Assign organisms to phylonodes' button
  $form['phylo_organism_btn'] = [
    '#type'   => 'submit',
    '#name'   => 'phylo_organism_btn',
    '#value'  => 'Assign organisms to phylonodes',
    '#prefix' => '<div style="padding-top:30px;"><em>'
                 . "Phylogenetic tree taxonomic tree leaf nodes will be assigned to"
                 . " organisms in the phylotree_organism table if such association"
                 . " does not already exist"
                 . "</em></div><br />",
    '#suffix' => "<hr>",
  ];

  return $form;
}

/**
 * Validates the form.
 *
 * @param $form
 * @param $form_state
 */
function carrotomics_admin_sql_form_validate($form, &$form_state) {
  // currently only buttons, so no validation is needed
}

/**
 * Submits the form.
 *
 * @param $form
 * @param $form_state
 */
function carrotomics_admin_sql_form_submit($form, &$form_state) {
  $form_state['rebuild'] = TRUE;

  // Gets the trigger element, i.e. which button was pressed
  $triggering_element = $form_state['triggering_element']['#name'];

  // Take action depending on which button was pressed
  if ($triggering_element == 'clean_md5_btn') {
    [$nerrors, $status] = carrotomics_admin_remove_useless_checksums();
  }
  else if ($triggering_element == 'clean_taxid_btn') {
    [$nerrors, $status] = carrotomics_admin_clean_taxid();
  }
  else if ($triggering_element == 'pop_org_abbrev_btn') {
    [$nerrors, $status] = carrotomics_admin_populate_abbreviations();
  }
  else if ($triggering_element == 'residues_btn') {
    [$nerrors, $status] = carrotomics_admin_residues_length_checksum();
  }
  else if ($triggering_element == 'qtl_abbrev_btn') {
    [$nerrors, $status] = carrotomics_admin_qtl_abbrev();
  }
  else if ($triggering_element == 'genetic_marker_marker_locus_fix_btn') {
    [$nerrors, $status] = carrotomics_admin_genetic_marker_marker_locus_fix();
  }
  else if ($triggering_element == 'stock_analysis_btn') {
    [$nerrors, $status] = carrotomics_admin_stock_analysis_linker();
  }
  else if ($triggering_element == 'map_prop_btn') {
    [$nerrors, $status] = carrotomics_admin_generate_featuremapprop();
  }
  else if ($triggering_element == 'phylo_organism_btn') {
    [$nerrors, $status] = carrotomics_admin_phylotree_organism();
  }
  else {
    [$nerrors, $status] = [1, "Unknown button \"$triggering_element\" was pressed"];
  }
  drupal_set_message($status, $nerrors?'error':'status');
}

/**
 * Many features get an md5 checksum generated for a null string.
 * These are not useful. This function will remove them.
 */
function carrotomics_admin_remove_useless_checksums() {
  // equivalent SQL: UPDATE chado.feature SET md5checksum = NULL WHERE md5checksum = 'd41d8cd98f00b204e9800998ecf8427e';

  $where = [ 'md5checksum' => 'd41d8cd98f00b204e9800998ecf8427e' ];
  $newvalues = [ 'md5checksum' => NULL ];

  // First get number of matching records that we will update, since
  // chado_update_record only returns true or false
  $resultarray = chado_select_record('feature', [], $where);
  $nchanged = sizeof($resultarray);

  // Now make the changes
  try {
    $success = chado_update_record('feature', $where, $newvalues);
  } catch (Exception $e) {
    return [1, $e->getMessage()];
  }
  if ($success) {
    return [0, "$nchanged records updated"];
  }
  else {
    return [1, "$nchanged records to update, but something unexpected went wrong"];
  }
}

/**
 * Many features get an md5 checksum generated for a null string.
 * These are not useful. This function will remove them.
 */
function carrotomics_admin_clean_taxid() {
  // I have hardcoded the dbxref values for the placeholder records

  // First get number of matching records that we will update
  $sql = "SELECT COUNT(*) FROM {organism_dbxref} WHERE dbxref_id in (3843, 3910)";
  $args = [];
  $count = chado_query($sql, $args)->fetchField();

  if ($count) {
    $sql = "DELETE FROM {organism_dbxref} WHERE dbxref_id in (3843, 3910)";
    $args = [];
    $result = chado_query($sql, $args);
  }

  if ($count) {
    return [0, "$count placeholder records removed"];
  }
  else {
    return [0, "There were no placeholder records to remove"];
  }
}

/**
 * Populate organism abbreviations using the
 * chado_get_organism_scientific_name() function.
 */
function carrotomics_admin_populate_abbreviations() {
  $nupdated = 0;
  $nerrors = 0;

  // First get the list of organisms with a NULL or blank abbreviation
  $sql1 = "SELECT organism_id FROM {organism} WHERE (abbreviation <> '') IS NOT TRUE";
  $args1 = [];
  try {
    $results1 = chado_query($sql1, $args1);
  } catch (Exception $e) {
    return [1, $e->getMessage()];
  }

  // Next update each missing abbreviation
  while ($obj = $results1->fetchObject()) {
    $organism_id = $obj->organism_id;
    $sciname = chado_get_organism_scientific_name(chado_get_organism(['organism_id' => $organism_id], []));
    if ($sciname) {
      $sql2 = "UPDATE {organism} SET abbreviation=:abbreviation WHERE organism_id=:organism_id";
      $args2 = [':abbreviation' => $sciname, ':organism_id' => $organism_id];
      try {
        $results2 = chado_query($sql2, $args2);
      } catch (Exception $e) {
        return [1, $e->getMessage()];
      }
      $nupdated++;
    }
    else {
      $nerrors++;
    }
  }

  if ($nupdated) {
    return [$nerrors, "$nupdated organism abbreviations were populated, $nerrors errors"];
  }
  else {
    return [$nerrors, "There were no missing organism abbreviations, $nerrors errors"];
  }
}

/**
 * When a feature has a value in the residues column, the
 * associated seqlen and md5checksum values should also be present.
 * When this is not the case, this function fills in those values.
 */
function carrotomics_admin_residues_length_checksum() {
  $errors = '';
  $nerrors = 0;
  $nupdated = 0;

  // Retrieve a list of chado.feature records missing length or checksum.
  // There are both empty strings and NULL values in both residues and md5checksum
  $sql = "SELECT feature_id, residues FROM {feature}"
       . " WHERE (residues = '') IS FALSE"  // i.e. not NULL and not empty string
       . " AND ((seqlen = 0) IS NOT FALSE"  // i.e. either NULL or zero
       . " OR (md5checksum = '') IS NOT FALSE)";  // i.e. either NULL or empty string
  $args = [];
  try {
    $results = chado_query($sql, $args);
  } catch (Exception $e) {
    return [1, $e->getMessage()];
  }

  // Validate the residue column before proceeding.
  // Errors will have to be dealt with manually
  while ($obj = $results->fetchObject()) {
    $feature_id = $obj->feature_id;
    $residues = $obj->residues;
    if (preg_match('/([^ABCDEFGHIKLMNPQRSTVWXYZabcdefghiklmnpqrstvwxyz\*])/', $residues, $matches)) {
      $errors .= '<br>Invalid residue "'.$matches[1].'" in feature '.$feature_id;
      $nerrors++;
    }
    else {
      $nupdated++;
    }
  }

  // If no errors, proceed with the update
  if ( (!$nerrors) and ($nupdated) ) {
    $sql = "UPDATE {feature}"
         . " SET seqlen=CHAR_LENGTH(residues), md5checksum=MD5(residues)"
         . " WHERE (residues = '') IS FALSE"
         . " AND ((seqlen = 0) IS NOT FALSE"
         . " OR (md5checksum = '') IS NOT FALSE)";
    $args = [];
    try {
      $results = chado_query($sql, $args);
    } catch (Exception $e) {
      return [1, $e->getMessage()];
    }
  }
  else {
    $nupdated = 0;
  }
  $status = t('Updated @nupdated features, @nerrors errors',
              ['@nupdated' => $nupdated, '@nerrors' => $nerrors]);
  return [$nerrors, $status . $errors];
}

/**
 * Generate featureprop entries with MAIN::published_symbol cvterm
 * for all QTL lacking them, if they are of the format MK012345 anytext
 *
 */
function carrotomics_admin_qtl_abbrev() {
  $errors = '';

  // get cvterm_id for QTL
  [$error, $qtl_type_id] = carrotomics_lookup_cvterm_id('sequence', 'QTL');
  if ($error ){ return[$error, $qtl_type_id]; }

  // get cvterm_id to use for featureprop table from MAIN::published_symbol
  [$error, $symbol_type_id] = carrotomics_lookup_cvterm_id('MAIN', 'published_symbol');
  if ($error ){ return[$error, $symbol_type_id]; }

  // retrieve an array of all QTL lacking the published_symbol property
  // the query retrieves all QTL featureprop, and in the loop flag those
  // that already have a published_symbol
  $sql = "SELECT DISTINCT F.feature_id, F.name, F.uniquename, FP.type_id FROM {feature} F"
       . " LEFT JOIN {featureprop} FP ON F.feature_id=FP.feature_id"
       . " WHERE F.type_id=:qtl_type_id";
  $args = [':qtl_type_id' => $qtl_type_id];
  try {
    $results = chado_query($sql, $args);
  } catch (Exception $e) {
    return [1, $e->getMessage()];
  }
  $qtls = [];
  // we will often iterate the same feature_id multiple times due to multiple featureprop records
  while ($obj = $results->fetchObject()) {
    $qtls[$obj->feature_id]['name'] = $obj->uniquename;
    if ($obj->type_id == $symbol_type_id) {
      $qtls[$obj->feature_id]['exclude'] = 1;
    }
  }

  // loop to add missing published_symbol entries to the featureprop table
  $rank = 0;  // all added lines will have this rank value. Since they are new, there is no possibility of conflict
  $nadded = 0;
  $nskipped = 0;
  $nerrors = 0;
  foreach($qtls as $feature_id => $record) {
    $uniquename = $record['name'];
    $exclude = array_key_exists('exclude', $record);  // defined only when excluded
    // skip if excluded because it already has a published_symbol
    if (!$exclude) {
      // Derive name by removing the 'MK012345 ' portion. If that's missing, skip it
      if ( preg_match('/^MK\d{6} (.*)/', $uniquename, $matches) ) {
        $published_symbol = $matches[1];
        if ($published_symbol) {
          $values = [ 'feature_id' => $feature_id,
                      'type_id' => $symbol_type_id,
                      'value' => $published_symbol,
                      'rank' => $rank ];
          try {
            $result = chado_insert_record('featureprop', $values);
            if ($result) {
              $nadded++;
            }
            else {
              $nerrors++;
            }
          } catch (Exception $e) {
            $nerrors++;
            $errors .= '<br />' . $e->getMessage();
          }
        }
        else {
          $errors .= "Unparseable name \"$uniquename\"<br>";
          $nerrors++;
        }
      }
      else {
        $nskipped++;
      }
    }
  }

  $status = t('Added @nadded published_names, @nskipped skipped, @nerrors errors',
              ['@nadded' => $nadded, '@nskipped' => $nskipped, '@nerrors' => $nerrors]);
  return [$nerrors, $status . $errors];
}

/**
 *
 * Removes non-alphanumeric or underscore from all features of type genetic_marker,
 * and make sure corresponding marker_locus features have the same uniquename.
 * genetic_marker and marker_locus are related through the feature_relationship table.
 *
 */
function carrotomics_admin_genetic_marker_marker_locus_fix() {
  $status = '';
  $nupdated_g_m = 0;
  $nupdated_m_l = 0;
  $errors = '';
  $nerrors = 0;

  // get cvterm_id for sequence::genetic_marker (1911)
  [$error, $genetic_marker_type_id] = carrotomics_lookup_cvterm_id('sequence', 'genetic_marker');
  if ($error ){ return[$error, $genetic_marker_type_id]; }

  // get cvterm_id for MAIN::marker_locus (51099)
  [$error, $marker_locus_type_id] = carrotomics_lookup_cvterm_id('MAIN', 'marker_locus');
  if ($error ){ return[$error, $marker_locus_type_id]; }

  // get cvterm_id for relationship::instance_of (50973)
  [$error, $instance_of_type_id] = carrotomics_lookup_cvterm_id('relationship', 'instance_of');
  if ($error ){ return[$error, $instance_of_type_id]; }

  // Although this could all be done in SQL, implement update as an inefficient loop
  // so that if anything goes wrong a useful error message can be generated, most
  // likely breaking the unique constraint somehow.
  $sql1 = 'SELECT F1.feature_id AS fid1, F1.uniquename AS un1, F2.feature_id AS fid2, F2.uniquename AS un2 FROM {feature} F1'
        . ' LEFT JOIN feature_relationship FR ON F1.feature_id=FR.object_id'
        . ' LEFT JOIN feature F2 ON FR.subject_id=F2.feature_id'
        . ' WHERE F1.type_id=:genetic_marker_type_id'
        . ' AND FR.type_id=:instance_of_type_id'
        . ' AND F2.type_id=:marker_locus_type_id'
        . " AND (F1.uniquename ~ '[^A-Za-z0-9_]' OR NOT F1.uniquename = F2.uniquename)"
        . ' ORDER BY F1.feature_id';
  $args1 = [':genetic_marker_type_id' => $genetic_marker_type_id,
            ':instance_of_type_id' => $instance_of_type_id,
            ':marker_locus_type_id' => $marker_locus_type_id];
  try {
    $results1 = chado_query($sql1, $args1);
  } catch (Exception $e) {
    return [1, $e->getMessage()];
  }

  // main processing loop
  while ($obj = $results1->fetchObject()) {
    $fid1 = $obj->fid1;
    $un1 = $obj->un1;
    $origun1 = $un1;
    $fid2 = $obj->fid2;
    $un2 = $obj->un2;

    // Part 1, fix genetic_marker uniquename "bad" characters
    if (preg_match('/[^A-Za-z0-9_]/', $un1)) {
      $un1 = preg_replace('/[^A-Za-z0-9_]/', '_', $un1);
      $sql2 = 'UPDATE {feature} SET uniquename=:un1 WHERE feature_id=:fid1';
      $args2 = [':un1' => $un1, ':fid1' => $fid1];
      try {
        chado_query($sql2, $args2);
        $nupdated_g_m++;
      } catch (Exception $e) {
        $errors .= "<br>Error updating genetic_marker feature_id=$fid1 from \"$origun1\" to \"$un1\" ".$e->getMessage()."\n";
        $nerrors++;
      }
    }

    // Part 2, fix cases where marker_locus uniquename is different from genetic_marker
    // uniquename (which was possibly updated in Part 1).
    if ($un2 != $un1) {
      $sql3 = 'UPDATE {feature} SET uniquename=:un1 WHERE feature_id=:fid2';
      $args3 = [':un1' => $un1, ':fid2' => $fid2];
      try {
        chado_query($sql3, $args3);
        $nupdated_m_l++;
      } catch (Exception $e) {
        $errors .= "<br>Error updating marker_locus feature_id=$fid2 from \"$un2\" to \"$un1\" ".$e->getMessage()."\n";
        $nerrors++;
      }
    }
    if ($nerrors) {
      $errors .= "<br>Error encountered, processing stopped.\n";
      break;
    }
  }

  $status .= t('Updated @nupdated_g_m genetic_marker uniquename records,'
            . ' updated @nupdated_m_l marker_locus uniquename records,'
            . ' @nerrors errors',
              ['@nupdated_g_m' => $nupdated_g_m,
               '@nupdated_m_l' => $nupdated_m_l,
               '@nerrors' => $nerrors]);
  return [$nerrors, $status . $errors];
}

/**
 * Generate entries in the chado.stock_analysis custom table that
 * are used by the local__stock_analysis field to link a stock to
 * any analyses using that stock. Here entries are derived from
 * phylogenetic trees.
 *
 */
function carrotomics_admin_stock_analysis_linker() {
  $nexisting = 0;
  $nadded = 0;
  $nduplicated = 0;  // Redundant, due to multiple trees per study
  $nerrors = 0;
  $errors = '';
  $previously_added = [];  // More efficient to cache added values locally

  // get cvterm_id for 'part_of' from the 'relationship' CV, which
  // is used to link tree analyses to the parent study analysis
  [$error, $part_of_id] = carrotomics_lookup_cvterm_id('relationship', 'part_of');
  if ($error ){ return[$error, $part_of_id]; }

  // starting from phylotree nodes, retrieve linked features from which we can
  // find linked stock entries. Existing links are returned so that we can count
  // them to display in the summary output.
  $sql = "SELECT FS.stock_id, T.analysis_id, R.object_id AS parent_analysis_id,"
    . "   R.type_id, SA1.stock_analysis_id AS existing1, SA2.stock_analysis_id AS existing2"
    . " FROM {phylonode} N"
    . " LEFT JOIN {feature} F ON N.feature_id=F.feature_id"
    . " LEFT JOIN {feature_stock} FS ON F.feature_id=FS.feature_id"
    . " LEFT JOIN {phylotree} T ON N.phylotree_id=T.phylotree_id"
    . " LEFT JOIN {analysis_relationship} R ON R.subject_id=T.analysis_id"
    . " LEFT JOIN {stock_analysis} SA1 ON FS.stock_id=SA1.stock_id AND T.analysis_id=SA1.analysis_id"
    . " LEFT JOIN {stock_analysis} SA2 ON FS.stock_id=SA2.stock_id AND R.object_id=SA2.analysis_id"
    . " WHERE N.feature_id IS NOT NULL"
    . " ORDER BY N.phylotree_id";
  $args = [];
  try {
    $results = chado_query($sql, $args);
  } catch (Exception $e) {
    return [1, $e->getMessage()];
  }
  $links = [];
  while ($obj = $results->fetchObject()) {
    $stock_id = $obj->stock_id;
    $analysis_id = $obj->analysis_id;
    $parent_analysis_id = $obj->parent_analysis_id;

    // child analysis
    if ($analysis_id) {
      if ($obj->existing1) {
        $nexisting++;
      }
      elseif (array_key_exists($stock_id.':'.$analysis_id, $previously_added)) {
        $nduplicated++;
      }
      else {
        $values = ['stock_id' => $stock_id, 'analysis_id' => $analysis_id];
        if (chado_insert_record('stock_analysis', $values, [])) {
          $nadded++;
          $previously_added[$stock_id.':'.$analysis_id] = 1;
        }
        else {
          $nerrors++;
        }
      }
    }

    // parent analysis, relationship type must be correct
    if (($parent_analysis_id) and ($obj->type_id) and ($obj->type_id == $part_of_id)) {
      if ($obj->existing2) {
        $nexisting++;
      }
      elseif (array_key_exists($stock_id.':'.$parent_analysis_id, $previously_added)) {
        $nduplicated++;
      }
      else {
        $values = ['stock_id' => $stock_id, 'analysis_id' => $parent_analysis_id];
        if (chado_insert_record('stock_analysis', $values, [])) {
          $nadded++;
          $previously_added[$stock_id.':'.$parent_analysis_id] = 1;
        }
        else {
          $nerrors++;
        }
      }
    }
  }

  $status = t('Found @nexisting existing links, added @nadded links,'
             . ' ignored @nduplicated redundant links, @nerrors errors',
              ['@nexisting' => $nexisting, '@nadded' => $nadded,
               '@nerrors' => $nerrors, '@nduplicated' => $nduplicated]);
  return [$nerrors, $status . $errors];
}

/**
 * Generate properties for the chado.featuremapprop table.
 *
 */
function carrotomics_admin_generate_featuremapprop() {
  $nmaps = 0;
  $nexisting = 0;
  $nadded = 0;
  $nerrors = 0;
  $errors = '';

  // get cvterm_id values for properties to be added
  [$error, $marker_count_id] = carrotomics_lookup_cvterm_id('local', 'Number of markers');
  if ($error ){ return[$error, $marker_count_id]; }
  [$error, $qtl_count_id] = carrotomics_lookup_cvterm_id('local', 'Number of quantitative trait loci');
  if ($error ){ return[$error, $qtl_count_id]; }
  [$error, $mtl_count_id] = carrotomics_lookup_cvterm_id('local', 'Number of mendelian trait loci');
  if ($error ){ return[$error, $mtl_count_id]; }
  [$error, $linkage_group_count_id] = carrotomics_lookup_cvterm_id('local', 'Number of linkage groups');
  if ($error ){ return[$error, $linkage_group_count_id]; }

  // Generate a list of featuremap_id values to process.
  $sql1 = "SELECT M.featuremap_id FROM {featuremap} M";
  $args1 = [];
  try {
    $results1 = chado_query($sql1, $args1);
  } catch (Exception $e) {
    return [1, $e->getMessage()];
  }
  $featuremap_ids = [];
  while ($obj = $results1->fetchObject()) {
    $featuremap_ids[] = $obj->featuremap_id;
    $nmaps++;
  }

  // Retrieve all existing properties.
  $sql2 = "SELECT P.featuremap_id, P.type_id, P.value FROM {featuremapprop} P"
        . " WHERE P.type_id IN (:t1, :t2, :t3, :t4)";
  $args2 = [':t1' => $marker_count_id, ':t2' => $qtl_count_id,
            ':t3' => $mtl_count_id, ':t4' => $linkage_group_count_id];
  try {
    $results2 = chado_query($sql2, $args2);
  } catch (Exception $e) {
    return [1, $e->getMessage()];
  }
  $properties = [];
  while ($obj = $results2->fetchObject()) {
    $properties[$obj->featuremap_id][$obj->type_id] = $obj->value;
    $nexisting++;
  }

  // For each map, generate and store missing properties.
  foreach ($featuremap_ids as $featuremap_id) {

    // Number of linkage groups
    if (!array_key_exists($featuremap_id, $properties) or !array_key_exists($linkage_group_count_id, $properties[$featuremap_id])) {
      $sql3 = "SELECT COUNT(DISTINCT(F.uniquename)) AS linkage_group_count FROM {featurepos} FP"
            . " LEFT JOIN {feature} F ON FP.map_feature_id=F.feature_id"
            . " WHERE FP.featuremap_id=:featuremap_id";
      $args3 = [':featuremap_id' => $featuremap_id];
      $linkage_group_count = chado_query($sql3, $args3)->fetchField();
      if ($linkage_group_count) {
        $sql4 = "INSERT INTO {featuremapprop} (featuremap_id, type_id, value, rank)"
              . " VALUES (:featuremap_id, :type_id, :value, :rank)";
        $args4 = [':featuremap_id' => $featuremap_id, ':type_id' => $linkage_group_count_id,
                  ':value' => $linkage_group_count, ':rank' => 0];
        try {
          $results4 = chado_query($sql4, $args4);
        } catch (Exception $e) {
          return [1, $e->getMessage()];
        }
        $nadded++;
      }
      else {
        $nerrors++;
        $errors .= " Map $featuremap_id has no linkage groups";
      }
    }

    // These three properties can share common SQL.
    $props = ['marker_locus' => $marker_count_id,
              'QTL' => $qtl_count_id,
              'heritable_phenotypic_marker' => $mtl_count_id];
    foreach ($props as $name => $type_id) {
      if (!array_key_exists($featuremap_id, $properties) or !array_key_exists($type_id, $properties[$featuremap_id])) {
        $sql5 = "SELECT COUNT(*) AS marker_count FROM {featurepos} FP"
              . " LEFT JOIN {feature} F ON FP.feature_id=F.feature_id"
              . " LEFT JOIN }cvterm} T ON F.type_id=T.cvterm_id"
              . " WHERE T.name=:name AND FP.featuremap_id=:featuremap_id";
        $args5 = [':name' => $name, ':featuremap_id' => $featuremap_id];
        $count = chado_query($sql5, $args5)->fetchField();
        // Here a count of zero is valid, e.g. no QTL on this map.
        $sql6 = "INSERT INTO {featuremapprop} (featuremap_id, type_id, value, rank)"
              . " VALUES (:featuremap_id, :type_id, :value, :rank)";
        $args6 = [':featuremap_id' => $featuremap_id, ':type_id' => $type_id,
                  ':value' => $count, ':rank' => 0];
        try {
          $results6 = chado_query($sql6, $args6);
        } catch (Exception $e) {
          return [1, $e->getMessage()];
        }
        $nadded++;
      }
    }
  }

  $status = t('For @nmaps maps, @nexisting properties exist, added @nadded properties, @nerrors errors',
              ['@nmaps' => $nmaps, '@nexisting' => $nexisting, '@nadded' => $nadded, '@nerrors' => $nerrors]);
  return [$nerrors, $status . $errors];
}

/**
 * Generate links in the chado.phylotree_organism table based on
 * leaf node names for taxonomic trees
 *
 */
function carrotomics_admin_phylotree_organism() {
  $errors = '';
  $nerrors = 0;
  $nadded = 0;
  $nfailed = 0;

  // get cvterm_id for "taxonomic" trees
  [$error, $tree_type_id] = carrotomics_lookup_cvterm_id('EDAM', 'Species tree');
  if ($error ){ return[$error, $tree_type_id]; }

  // get cvterm_id for leaf nodes
  [$error, $leaf_type_id] = carrotomics_lookup_cvterm_id('tripal_phylogeny', 'phylo_leaf');
  if ($error ){ return[$error, $leaf_type_id]; }

  // retrieve an array of all candidate leaf nodes without existing
  // links in the phylonode_organism table, that are in "taxonomic" ("Species_tree") trees
  $sql = "SELECT PN.phylonode_id, PN.label FROM {phylonode} PN"
       . " LEFT JOIN {phylotree} PT ON PN.phylotree_id = PT.phylotree_id"
       . " LEFT JOIN {phylonode_organism} PO ON PN.phylonode_id=PO.phylonode_id"
       . " WHERE PT.type_id=:tree_id"
       . " AND PN.type_id=:node_id"
       . " AND PO.organism_id IS NULL";
  $args = [':tree_id' => $tree_type_id, ':node_id' => $leaf_type_id];
  try {
    $results = chado_query($sql, $args);
  } catch (Exception $e) {
    return [1, $e->getMessage()];
  }
  while ($obj = $results->fetchObject()) {
    $phylonode_id = $obj->phylonode_id;
    $label = $obj->label;
    $organism_id = carrotomics_admin_lookup_organism_by_name($label);
    if ($organism_id) {
      try {
        $values = ['phylonode_id' => $phylonode_id,
                   'organism_id' => $organism_id];
        $result = chado_insert_record('phylonode_organism', $values);
        if ($result) {
          $nadded++;
        }
        else {
          $nerrors++;
        }
      } catch (Exception $e) {
        $nerrors++;
        $errors .= '<br />' . $e->getMessage();
      }
    }
    else {
      $nfailed++;
      $errors .= '<br />Unable to look up ' . $label;
    }
  }

  $status = t('Added @nadded organism links, @nfailed unable to determine organism, @nerrors errors',
              ['@nadded' => $nadded, '@nfailed' => $nfailed, '@nerrors' => $nerrors]);
  return [$nerrors, $status . $errors];
}

/**
 * Lookup an organism_id given an organism name (genus species)
 *
 * @param $name
 *   The organism name.
 *
 * @return
 *  organism_id from chado.organism table or FALSE on failure.
 */
function carrotomics_admin_lookup_organism_by_name($name) {
  $organism_id = false;

  // spaces in names are likely to be replaced with underscores in newick files
  $name = trim(preg_replace('/_/', ' ', $name ));

  // TreeBASE trees have a study prefix, remove that if present
  $name = preg_replace('/^S\d+ /', '', $name);

  // First try to find name as it is in the abbreviation column. This does not
  // have a unique constraint, so we must verify that the count is 1
  $sql = "SELECT COUNT(*) FROM {organism} WHERE abbreviation = :name";
  $args = [':name' => $name];
  $count = chado_query($sql, $args)->fetchField();
  if ($count == 1) {
    $sql = "SELECT organism_id FROM {organism} WHERE abbreviation = :name";
    $organism_id = $chado_query($sql, $args)->fetchField();
  }

  // abbreviation query failed, so now query on genus + species and
  // optionally infraspecific nomenclature
  else {
    $infrasupported = false;
    $limit = 2;
    if (chado_column_exists('organism', 'infraspecific_name')) {
      $infrasupported = true;
      $limit = 4;
    }
    $parts = preg_split('/\s+/', $name, $limit);
    $sql = "SELECT organism_id FROM {organism} WHERE genus = :genus AND species = :species";
    $args = [ ':genus' => $parts[0], ':species' => $parts[1] ];
    if ($infrasupported) {
      // when there is no infraspecific name, we can use the "no_rank" taxonomic term in
      // the type_id column, or NULL can be considered equivalent. Wrap these in parentheses
      $sql .= " AND ( type_id = (SELECT cvterm_id FROM {cvterm} WHERE name = :infraspecific_type"
           . " AND cv_id = (SELECT cv_id FROM {cv} WHERE name = 'taxonomic_rank'))";
      if (!array_key_exists(2, $parts)) {
        $parts[2] = 'no_rank';
        $sql .= " OR type_id IS NULL";
      }
      else {
        $parts[2] = chado_unabbreviate_infraspecific_rank($parts[2]);
      }
      $sql .= ")";
      $parts[3] = array_key_exists(3, $parts) ? $parts[3] : false;
      $args = array_merge( $args, [':infraspecific_type' => $parts[2]] );
      // if no infraspecific name, specify empty string or null in the SQL
      if ($parts[3]) {
        $sql .= " AND infraspecific_name = :infraspecific_name";
        $args = array_merge( $args, [':infraspecific_name' => $parts[3]] );
      }
      else {
        $sql .= " AND ( infraspecific_name = '' ) IS NOT FALSE";  // must be either empty string or NULL
      }
    }
    // unique constraint on organism table ensures we get zero or one record returned
    $organism_id = chado_query($sql, $args)->fetchField();
  }
  return($organism_id);
}
